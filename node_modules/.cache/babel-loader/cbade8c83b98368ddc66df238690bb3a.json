{"ast":null,"code":"// Creational design patterns:\n// Provide a mechanism to create an object and without revealing the creation method.\n// - Factory\n// Provides a template to create an object. Can be used when the type of object to create can be\n// different and needs to be specified in every instatiation. Does not require the keyword 'new' to instatiate.\nclass IceCreamFactory {\n  constructor() {\n    this.iceCreamFactory = function (flavor) {\n      let iceCream;\n\n      if (flavor === \"chocolate\") {\n        iceCream = new Chocolate();\n      } else if (flavor === 'mint') {\n        iceCream = new Mint();\n      } else if (flavor === 'strawberry') {\n        iceCream = new Strawberry();\n      }\n\n      return iceCream;\n    };\n  }\n\n}\n\nclass Chocolate {\n  constructor() {\n    this.icecreamFlavor = \"chocolate\";\n\n    this.message = function () {\n      return `You chose the ${this.icecreamFlavor} flavor.`;\n    };\n  }\n\n}\n\nclass Mint {\n  constructor() {\n    this.icecreamFlavor = \"mint\";\n\n    this.message = function () {\n      return `You chose the ${this.icecreamFlavor} flavor.`;\n    };\n  }\n\n}\n\nclass Strawberry {\n  constructor() {\n    this.icecreamFlavor = \"strawberry\";\n\n    this.message = function () {\n      return `You chose the ${this.icecreamFlavor} flavor.`;\n    };\n  }\n\n} // creating objects\n\n\nconst iceCreamfactory = new IceCreamFactory();\nconst chocolate = iceCreamfactory.iceCreamFactory('chocolate');\nconst mint = iceCreamfactory.iceCreamFactory('mint');\nconst strawberry = iceCreamfactory.iceCreamFactory('strawberry');\nconsole.log(chocolate.message());\nconsole.log(mint.message());\nconsole.log(strawberry.message()); // - Constructor\n// - Builder\n// - Abstract\n// - Prototype\n// - Singleton\n// Structural design patterns:\n// Patterns that concern the class/object composition. They let you add new functionalities to object so in case the\n// system changes it might be easy to add things to the core without affecting the rest\n// - Facade\n// - Decorator\n// - Proxy\n// - Flyweight\n// - Bridge\n// - Composite\n// - Adapter\n// Behavioral design patterns\n// They are used when we need dissimilar objects to communicate. They streamline the communication between objects\n// so they are always in sync.\n// - Revealing module\n// - Chain of responsabilty\n// - Strategy\n// - Interpreter\n// - Command\n// - Observer\n// - Iterator\n// - Mediator\n// - Visitor\n// - State\n// - Memento\n// Architectural design patterns\n// - MVC\n// - MVP\n// - MVVC","map":{"version":3,"sources":["C:/Users/Michael/Documents/reactJS/react-full-stack-test/src/components/lauch-card/index.js"],"names":["IceCreamFactory","constructor","iceCreamFactory","flavor","iceCream","Chocolate","Mint","Strawberry","icecreamFlavor","message","iceCreamfactory","chocolate","mint","strawberry","console","log"],"mappings":"AAAA;AACA;AAEA;AACA;AACA;AAEA,MAAMA,eAAN,CAAsB;AACpBC,EAAAA,WAAW,GAAG;AACZ,SAAKC,eAAL,GAAuB,UAAUC,MAAV,EAAkB;AACvC,UAAIC,QAAJ;;AAEA,UAAID,MAAM,KAAK,WAAf,EAA4B;AAC1BC,QAAAA,QAAQ,GAAG,IAAIC,SAAJ,EAAX;AACD,OAFD,MAGK,IAAIF,MAAM,KAAK,MAAf,EAAsB;AACzBC,QAAAA,QAAQ,GAAG,IAAIE,IAAJ,EAAX;AACD,OAFI,MAGA,IAAIH,MAAM,KAAK,YAAf,EAA4B;AAC7BC,QAAAA,QAAQ,GAAG,IAAIG,UAAJ,EAAX;AACH;;AACD,aAAOH,QAAP;AACD,KAbD;AAcD;;AAhBmB;;AAmBtB,MAAMC,SAAN,CAAgB;AACdJ,EAAAA,WAAW,GAAG;AACZ,SAAKO,cAAL,GAAsB,WAAtB;;AACA,SAAKC,OAAL,GAAe,YAAW;AACxB,aAAQ,iBAAgB,KAAKD,cAAe,UAA5C;AACD,KAFD;AAGD;;AANa;;AAShB,MAAMF,IAAN,CAAW;AACTL,EAAAA,WAAW,GAAG;AACZ,SAAKO,cAAL,GAAsB,MAAtB;;AACA,SAAKC,OAAL,GAAe,YAAW;AACxB,aAAQ,iBAAgB,KAAKD,cAAe,UAA5C;AACD,KAFD;AAGD;;AANQ;;AASX,MAAMD,UAAN,CAAgB;AACdN,EAAAA,WAAW,GAAG;AACZ,SAAKO,cAAL,GAAsB,YAAtB;;AACA,SAAKC,OAAL,GAAe,YAAW;AACxB,aAAQ,iBAAgB,KAAKD,cAAe,UAA5C;AACD,KAFD;AAGD;;AANa,C,CAShB;;;AACA,MAAME,eAAe,GAAG,IAAIV,eAAJ,EAAxB;AAEA,MAAMW,SAAS,GAAGD,eAAe,CAACR,eAAhB,CAAgC,WAAhC,CAAlB;AACA,MAAMU,IAAI,GAAGF,eAAe,CAACR,eAAhB,CAAgC,MAAhC,CAAb;AACA,MAAMW,UAAU,GAAGH,eAAe,CAACR,eAAhB,CAAgC,YAAhC,CAAnB;AAEAY,OAAO,CAACC,GAAR,CAAYJ,SAAS,CAACF,OAAV,EAAZ;AACAK,OAAO,CAACC,GAAR,CAAYH,IAAI,CAACH,OAAL,EAAZ;AACAK,OAAO,CAACC,GAAR,CAAYF,UAAU,CAACJ,OAAX,EAAZ,E,CAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA","sourcesContent":["// Creational design patterns:\n// Provide a mechanism to create an object and without revealing the creation method.\n\n// - Factory\n// Provides a template to create an object. Can be used when the type of object to create can be\n// different and needs to be specified in every instatiation. Does not require the keyword 'new' to instatiate.\n\nclass IceCreamFactory {\n  constructor() {\n    this.iceCreamFactory = function (flavor) {\n      let iceCream;\n\n      if (flavor === \"chocolate\") {\n        iceCream = new Chocolate();\n      }\n      else if (flavor === 'mint'){\n        iceCream = new Mint();\n      } \n      else if (flavor === 'strawberry'){\n          iceCream = new Strawberry();\n      }\n      return iceCream;\n    };\n  }\n}\n\nclass Chocolate {\n  constructor() {\n    this.icecreamFlavor = \"chocolate\";\n    this.message = function() {\n      return `You chose the ${this.icecreamFlavor} flavor.`;\n    };\n  }\n}\n\nclass Mint {\n  constructor() {\n    this.icecreamFlavor = \"mint\";\n    this.message = function() {\n      return `You chose the ${this.icecreamFlavor} flavor.`;\n    };\n  }\n}\n\nclass Strawberry{\n  constructor() {\n    this.icecreamFlavor = \"strawberry\";\n    this.message = function() {\n      return `You chose the ${this.icecreamFlavor} flavor.`;\n    };\n  }\n}\n\n// creating objects\nconst iceCreamfactory = new IceCreamFactory();\n\nconst chocolate = iceCreamfactory.iceCreamFactory('chocolate');\nconst mint = iceCreamfactory.iceCreamFactory('mint');\nconst strawberry = iceCreamfactory.iceCreamFactory('strawberry');\n\nconsole.log(chocolate.message()); \nconsole.log(mint.message()); \nconsole.log(strawberry.message()); \n\n// - Constructor\n// - Builder\n// - Abstract\n// - Prototype\n// - Singleton\n\n// Structural design patterns:\n\n// Patterns that concern the class/object composition. They let you add new functionalities to object so in case the\n// system changes it might be easy to add things to the core without affecting the rest\n\n// - Facade\n// - Decorator\n// - Proxy\n// - Flyweight\n// - Bridge\n// - Composite\n// - Adapter\n\n// Behavioral design patterns\n\n// They are used when we need dissimilar objects to communicate. They streamline the communication between objects\n// so they are always in sync.\n\n// - Revealing module\n// - Chain of responsabilty\n// - Strategy\n// - Interpreter\n// - Command\n// - Observer\n// - Iterator\n// - Mediator\n// - Visitor\n// - State\n// - Memento\n\n// Architectural design patterns\n\n// - MVC\n// - MVP\n// - MVVC\n"]},"metadata":{},"sourceType":"module"}